<?php

namespace PhpRadixTreeGenerator\Tests\GeneratedCode;

use PhpRadixTreeGenerator\App\Console\Commands\Generate\Target;
use PhpRadixTreeGenerator\OS\File;
use PhpRadixTreeGenerator\RadixTree\Generator;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\TestCase;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;
use Symfony\Component\Serializer\Serializer;

final class RadixTreeTest extends TestCase
{
    /** @var array<string, array<string, string>> */
    private const DATA = [
        ['col-1' => 'AA-AA-1', 'col-2' => 'AA-AA-2', 'col-3' => 'AA-AA-3'],
        ['col-1' => 'AA-AB-1', 'col-2' => 'AA-AB-2', 'col-3' => 'AA-AB-3'],
        ['col-1' => 'BB-AA-1', 'col-2' => 'BB-AA-2', 'col-3' => 'BB-AA-3'],
        ['col-1' => 'BB-AB-1', 'col-2' => 'BB-AB-2', 'col-3' => 'BB-AB-3'],
    ];
    private const KEY_TO_INDEX_ON = 'col-1';
    /** @var array<array{dataSource: string, keyCol: string, namespace: string, className: string, minify: bool}> */
    private const TARGETS_TO_TEST = [
        [
            'dataSource' => ':in-memory:',
            'keyCol' => self::KEY_TO_INDEX_ON,
            'namespace' => 'PhpRadixTreeGenerator\Tests\GeneratedCode',
            'className' => 'RadixTreeUnderTest',
        ],
    ];

    public static function setUpBeforeClass(): void
    {
        parent::setUpBeforeClass(); // TODO: Change the autogenerated stub

        $serializer = new Serializer([new ObjectNormalizer()]);
        foreach (self::TARGETS_TO_TEST as $target) {
            /** @var Target $target */
            $target = $serializer->denormalize($target, Target::class);
            self::generateTargetUnderTest($target, new \ArrayIterator(self::DATA));
        }
    }

    #[DataProvider('searchProvider')]
    public function testSearch(string $classToTest, string $keyToSearch, bool $matchExact, array $expectedData): void
    {
        $expectedDataByKey = [];
        foreach ($expectedData as $expected) {
            $expectedDataByKey[$expected[self::KEY_TO_INDEX_ON]] = [
                'key' => $expected[self::KEY_TO_INDEX_ON],
                'value' => $expected,
            ];
        }

        $radix = new $classToTest();

        $actuals = $radix->search($keyToSearch, $matchExact);
        $this->assertSame(count($expectedDataByKey), count($actuals));
        foreach ($actuals as ['key' => $actualKey, 'value' => $actualValue]) {
            $this->assertSame($actualValue[self::KEY_TO_INDEX_ON], $actualKey);
            $this->assertArrayHasKey($actualKey, $expectedDataByKey);
            [
                'value' => $expectedValue,
            ] = $expectedDataByKey[$actualKey];
            foreach ($actualValue as $k => $v) {
                $this->assertArrayHasKey($k, $expectedValue);
                $this->assertSame($expectedValue[$k], $v);
                unset($expectedValue[$k]);
            }
            $this->assertEmpty($expectedValue);
        }
    }

    /**
     * @return array<string, array{0: array<string, string>, 1: string, 2: bool, 3: array<string, string>}>
     */
    public static function searchProvider(): array
    {
        $inserts = self::DATA;
        $targets = self::TARGETS_TO_TEST;
        /** @var array<string, array{0: array<string, string>, 1: string, 2: bool, 3: array<string, string>}> $testCases */
        $testCases = [];

        foreach ($targets as $target) {
            [
                'namespace' => $namespace,
                'className' => $className,
            ] = $target;
            $classFQN = $namespace . '\\' . $className;
            // ensure all inserts are matched exactly
            foreach ($inserts as $v) {
                $key = $v[self::KEY_TO_INDEX_ON];

                // exact match
                $desc = sprintf(
                    '%s: exact match: %s',
                    $className,
                    $key
                );
                $testCases[$desc] = [
                    $classFQN,
                    $key,
                    true,
                    array_filter(
                        self::DATA,
                        function (array $data) use ($key): bool {
                            return $data[self::KEY_TO_INDEX_ON] === $key;
                        }
                    ),
                ];

                // prefix matching
                $prefixKey = substr($key, 0, random_int(2, strlen($key) - 2));
                $desc = sprintf(
                    '%s: prefix match: %s',
                    $className,
                    $prefixKey
                );
                $testCases[$desc] = [
                    $classFQN,
                    $prefixKey,
                    false,
                    array_filter(
                        self::DATA,
                        function (array $data) use ($prefixKey): bool {
                            return str_starts_with($data[self::KEY_TO_INDEX_ON], $prefixKey);
                        }
                    ),
                ];
            }
        }
        return $testCases;
    }

    private static function generateTargetUnderTest(Target $target, \Iterator $dataIter): void
    {
        $fileToGenerate = __DIR__ . '/' . $target->className . '.php';
        $w = File::openFile($fileToGenerate, 'w+');
        try {
            $g = new Generator($target, $dataIter, $w, self::class);
            $g->generate();

            require_once $fileToGenerate;
            $w->close();
        } finally {
            $w->close();
        }
    }
}
